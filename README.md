# Wilberries - L1

## Ответы на вопросы:

### 1. Какой самый эффективный способ конкатенации строк?

Оператором copy в []byte
```golang
bs := make([]byte, b.N)
copy(bs[len(bs)-1:],stringToCopy)
```

Или писать в bytes.Buffer / strings.Builder

### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейс - набор методов, представляющих стандартное поведение для различных типов данных. Если структура обладает методами этого интерфейса - она его реализует(duck-typing). Отделяет реализацию, от того, как объект должен работать 


### 3. Чем отличаются RWMutex от Mutex?

Обыкновенный мьютекст может только "закрыться" и "открыться". RWMutex разделяет замок на чтение и на запись. Позволяет множеству потоков читать данные одновременно и в это время их не перезаписывать 

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Буферизированный канал может записать в себя несколько записей до того как заблокирует записывающий поток.

### 5. Какой размер у структуры struct{}{}?

0 байт

### 6. Есть ли в Go перегрузка методов или операторов?

нет

### 7. В какой последовательности будут выведены элементы map[int]int?

#### Пример:
```golang
m[0]=1
m[1]=124
m[2]=281
```

Возможная любая перестановка

### 8. В чем разница make и new?

new создает указатели.
make - объекты (канал, слайс, мапа)

### 9. Сколько существует способов задать переменную типа slice или map?

```golang
make([]int,len)
make([]int,len,cap)
[]int{}
make(map[keyT]valueT)
make(map[keyT]valueT,size)
map[key]valueT{}
```

### 10. Что выведет данная программа и почему?

```golang
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Выведет 1 и 1. В функции update не перезаписывается значение по указателю. Оригинальный a не затронут. Указатель p в main'е все еще указывает на a=1


### 11. Что выведет данная программа и почему?

```golang
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Выведет числа 0-4 в произвольном порядке и потом программа дедлокнется. sync.WaitGroup копируется и wg.Wait() никогда не завершится

### 12. Что выведет данная программа и почему?

```golang
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

Выведет 0, так как блоке под if'ом создается новая перменная n, не влияющая на "внешнюю"

### 13. Что выведет данная программа и почему?

```golang
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
[100 2 3 4 5]. Слайс - "ссылочный" а значит при изменении элементов v в someAction они изменятся и в a main'а. append никак не повлияет так как будет создаваться новый слайс. 


### 14. Что выведет данная программа и почему?

```golang
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
От функции - [b b a]. От main - [a a]. Как и в прошлом примере append создает новый слайс, он становится [a a a]. и все изменения происходят над новым слайсом, а не над старым